//
//
//  Generated by StarUML(tm) C++ Add-In
//
//  @ Project : 3D 카툰 메이커
//  @ File Name : LmCamera.cpp
//  @ Date : 2007-10-07
//  @ Author : 
//
//
#include "dxstdafx.h"
#include "LmCamera.h"

LmCamera::LmCamera()
{
	m_pCamera = new CModelViewerCamera;
	// 마스크 설정 - 모델 회전은 사용안한다.
	m_pCamera->SetButtonMasks(0, MOUSE_WHEEL, MOUSE_RIGHT_BUTTON);
	ResetEyePt();

	m_bEnableMouse = TRUE;
	m_uScreenWidth = 0;
	m_uScreenHeight = 0;
}

LmCamera::~LmCamera()
{
	if(m_pCamera != NULL)
	{
		delete m_pCamera;
		m_pCamera = NULL;
	}
}

LmCamera* LmCamera::GetInstance()
{
	static LmCamera g_Camera;

	return &g_Camera;
}

VOID LmCamera::Setup(UINT _uWidth, UINT _uHeight)
{
	m_uScreenWidth = _uWidth;
	m_uScreenHeight = _uHeight;

	// 카메라 프로젝션을 설정한다.
	float fAspectRatio = _uWidth / (FLOAT)_uHeight;
	m_pCamera->SetProjParams( D3DX_PI/4, fAspectRatio, 1.0f, 5000.0f );
	m_pCamera->SetWindow( _uWidth, _uHeight );

}

VOID LmCamera::Update(FLOAT _fTimeDelta)
{
	m_pCamera->FrameMove( _fTimeDelta );
}

// 주의: LmModel::Render()를 호출하기전에 호출하여, 설정한다.
VOID LmCamera::Render( LPDIRECT3DDEVICE9 _pDevice )
{
	D3DXMATRIXA16 mWorld;
	D3DXMATRIXA16 mView;
	D3DXMATRIXA16 mProj;
	D3DXMATRIXA16 mWorldViewProjection;

	// 카메라 클래스로부터 프로젝션과 뷰 행렬을 얻는다.
	mWorld = *m_pCamera->GetWorldMatrix();
	mProj = *m_pCamera->GetProjMatrix();
	mView = *m_pCamera->GetViewMatrix();

	mWorldViewProjection = mWorld * mView * mProj;

	// 투영행렬을 변환한다.
	_pDevice->SetTransform( D3DTS_VIEW, &mView );
	_pDevice->SetTransform( D3DTS_PROJECTION, &mProj );
}

BOOL LmCamera::HandleMessages(HWND _hWnd, UINT _uMsg, WPARAM _wParam, LPARAM _lParam )
{	
	if(!m_bEnableMouse)
		return FALSE;

	m_pCamera->HandleMessages(_hWnd, _uMsg, _wParam, _lParam );

	return TRUE;
}

CONST D3DXMATRIX* LmCamera::GetWorldMatrix() CONST
{
	return m_pCamera->GetWorldMatrix();
}

CONST D3DXMATRIX* LmCamera::GetProjMatrix() CONST
{
	return m_pCamera->GetProjMatrix();
}

CONST D3DXMATRIX* LmCamera::GetViewMatrix() CONST
{
	return m_pCamera->GetViewMatrix();
}

FLOAT LmCamera::GetDist() CONST
{
	D3DXVECTOR3 vLook = *m_pCamera->GetLookAtPt();
	D3DXVECTOR3 vEye = *m_pCamera->GetEyePt();

	D3DXVECTOR3 vDist = vEye - vLook;
	return D3DXVec3Length(&vDist);
}

CONST D3DXVECTOR3* LmCamera::GetEyePt() CONST
{
	return m_pCamera->GetEyePt();
}

VOID LmCamera::SetEyePt( FLOAT _fX, FLOAT _fY, FLOAT _fZ )
{
	D3DXVECTOR3 vEye(_fX, _fY, _fZ);
	D3DXVECTOR3 vLook(0.0f, 0.0f, 1.0f);
	m_pCamera->SetViewParams(&vEye, &vLook);
}

VOID LmCamera::ResetEyePt()
{
	SetEyePt(0.0f, 150.0f, -250.0f);
}

VOID LmCamera::AddDist( FLOAT _fD )
{
	D3DXVECTOR3 vEye = *GetEyePt();
	D3DXVECTOR3 vLook(0.0f, 0.0f, 1.0f);

	D3DXVECTOR3 vUnitDist;

	D3DXVec3Normalize(&vUnitDist, &(vEye - vLook));

	vEye += vUnitDist* _fD;

	SetEyePt(vEye.x, vEye.y, vEye.z);
}